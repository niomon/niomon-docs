"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[586],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return h}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=i.createContext({}),c=function(e){var t=i.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=c(e.components);return i.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,d=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,f=u["".concat(d,".").concat(h)]||u[h]||p[h]||r;return n?i.createElement(f,o(o({ref:t},s),{},{components:n})):i.createElement(f,o({ref:t},s))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},486:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return r},metadata:function(){return l},toc:function(){return c}});var i=n(3117),a=(n(7294),n(3905));const r={title:"Specification"},o="Token Pass Specification",l={unversionedId:"walletkit/token-pass/spec",id:"walletkit/token-pass/spec",title:"Specification",description:"Abstract",source:"@site/docs/walletkit/token-pass/spec.md",sourceDirName:"walletkit/token-pass",slug:"/walletkit/token-pass/spec",permalink:"/docs/walletkit/token-pass/spec",draft:!1,editUrl:"https://github.com/niomon/niomon-docs/blob/main/docs/walletkit/token-pass/spec.md",tags:[],version:"current",lastUpdatedAt:1667986870,formattedLastUpdatedAt:"Nov 9, 2022",frontMatter:{title:"Specification"},sidebar:"docs",previous:{title:"Token Pass",permalink:"/docs/walletkit/token-pass/"},next:{title:"API References",permalink:"/docs/category/api-references"}},d={},c=[{value:"Abstract",id:"abstract",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Representation",id:"representation",level:2},{value:"Decentralized Identifier",id:"decentralized-identifier",level:3},{value:"Credential",id:"credential",level:3},{value:"Proof",id:"proof",level:3},{value:"Example",id:"example",level:3},{value:"QR Encoding",id:"qr-encoding",level:3},{value:"Decentralized Identity",id:"decentralized-identity",level:2},{value:"DID Document",id:"did-document",level:3},{value:"DID Registry",id:"did-registry",level:3},{value:"Verification",id:"verification",level:2},{value:"Security Considerations",id:"security-considerations",level:2}],s={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"token-pass-specification"},"Token Pass Specification"),(0,a.kt)("h2",{id:"abstract"},"Abstract"),(0,a.kt)("p",null,"This document describe the generation and verification of Token Pass, a W3C Verifiable Credential that proves the Verifiable Credential Presenter has ownership, or control, of certain NFT."),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Token Pass is a W3C Verifiable Credential asserting that the presenter has ownership of an NFT. It can be used for tokengating events in which eligibility to entry is determined by whether the participant has ownership of certain NFTs. The participant signs a proof using an blockchain wallet application, and the proof is attached to the Verifiable Credential to be presented for verification."),(0,a.kt)("p",null,"By using Verifiable Credential and Decentralized Identity standards, it is possible to delegate ownership to another wallet, so that another wallet address can sign proofs on behalf of the owning address."),(0,a.kt)("p",null,"The Token Pass can be optionally encoded in a QR code so that it can be presented and scanned in person."),(0,a.kt)("h2",{id:"representation"},"Representation"),(0,a.kt)("p",null,"The Token Pass is a Verifiable Credential that contains a number of claims and proofs. Representation of a Token Pass MUST use the same data model and definitions as the specification of Verifiable Credential Data Model."),(0,a.kt)("h3",{id:"decentralized-identifier"},"Decentralized Identifier"),(0,a.kt)("p",null,"The decentralized identifier of the NFT is defined as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},"did:ethrnft:chain:contractAddress:tokenId\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"did")," - literal ",(0,a.kt)("inlineCode",{parentName:"li"},"did")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ethrnft")," - literal ",(0,a.kt)("inlineCode",{parentName:"li"},"ethrnft")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"chain")," - a hex string of the chain ID of the blockchain"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"contractAddress")," - a hex string of the NFT\u2019s contract address"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tokenId")," - a hex string of the NFT\u2019s token ID")),(0,a.kt)("p",null,"Example:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"did:ethrnft:0x1:0x00420000123456789abcdef0123456789abcdef0:0x01d681")),(0,a.kt)("h3",{id:"credential"},"Credential"),(0,a.kt)("p",null,"A typical Token Pass Generator SHOULD include the following properties: "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"id")," - The value SHOULD be a unique identifier of this credential."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"credentialSubject")," - The value CAN be an object or a set of objects, each MUST contain an ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," property.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"id")," - This property MUST be present. The value MUST be the decentralized identifier of the NFT to be claimed ownership of"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"issuanceDate")," - the value MUST be an ISO8601 formatted string representing the date and time the credential becomes valid."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"expirationDate")," - The value MUST be an ISO8601 formatted string representing the date and time the credential ceases to be valid.")),(0,a.kt)("p",null,"While the Verifiable Credential Data Model specification defines these properties to be optional, a typical Token Pass Verifier CAN require that these properties be present. This is often the case for ",(0,a.kt)("inlineCode",{parentName:"p"},"credentialSubject")," because without this property, the credential makes no claims of any NFTs."),(0,a.kt)("h3",{id:"proof"},"Proof"),(0,a.kt)("p",null,"The Token Pass Generator SHOULD use ",(0,a.kt)("inlineCode",{parentName:"p"},"EthereumEip712Signature2021")," to generate the proof of the claim. A typical Proof should include the following properties:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"type")," - The value SHOULD be ",(0,a.kt)("inlineCode",{parentName:"li"},"EthereumEip712Signature2021"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"created")," - The value MUST be an ISO8601 formatted string representing the date and time the proof is generated."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"proofPurpose")," - The value SHOULD be ",(0,a.kt)("inlineCode",{parentName:"li"},"assertionMethod"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"proofValue")," - The value MUST be hex encoded output of the EIP712 signature function using the ",(0,a.kt)("inlineCode",{parentName:"li"},"EthereumEip712Signature2021")," signature suite."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"verificationMethod")," - The value MUST be the ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," of the verification method defined in the NFT\u2019s DID Document. The value SHOULD be the decentralized identifier of the NFT, followed by ",(0,a.kt)("inlineCode",{parentName:"li"},"#owner"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"eip712")," - The value SHOULD be an object containing these properties:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"primaryType")," - The value MUST be ",(0,a.kt)("inlineCode",{parentName:"li"},"VerifiableCredential"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"domain")," - The value MUST be the same as the domain object defined in EIP712.")))),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "@context": [\n    "https://www.w3.org/2018/credentials/v1"\n  ],\n  "id": "did:ethrnft:0x1:0x00420000123456789abcdef0123456789abcdef0:0x01d681",\n  "type": [\n    "VerifiableCredential"\n  ],\n  "expirationDate": "2022-10-27T09:43:05.295Z",\n  "credentialSubject": {\n    "id": "did:ethrnft:0x1:0x00420000123456789abcdef0123456789abcdef0:0x01d681"\n  },\n  "proof": {\n    "type": "EthereumEip712Signature2021",\n    "created": "2022-10-27T09:42:06.403Z",\n    "proofPurpose": "assertionMethod",\n    "proofValue": "0x6319bfa27681c797b4154bfa23cfa4d363e1d7a3e3973b37f408269659dd041a03630adefd2d6ebbca47e4bfa09c246121cfec734806da32654d6232bb0a82191c",\n    "verificationMethod": "did:ethrnft:0x1:0x00420000123456789abcdef0123456789abcdef0:0x01d681#owner",\n    "eip712": {\n      "primaryType": "VerifiableCredential",\n      "domain": {\n        "version": "1"\n      }\n    }\n  }\n}\n')),(0,a.kt)("h3",{id:"qr-encoding"},"QR Encoding"),(0,a.kt)("p",null,"Token Pass CAN be encoded as a QR code for presentation at a physical location. When encoded as a QR code, the Verifiable Credential CAN be compressed using zlib compression. If compression is applied, the compressed data MUST be encoded using base45 encoding scheme."),(0,a.kt)("h2",{id:"decentralized-identity"},"Decentralized Identity"),(0,a.kt)("h3",{id:"did-document"},"DID Document"),(0,a.kt)("p",null,"A Token Pass Verifier SHOULD generates a DID Document using the decentralized identifier of the claimed NFT. The resolved document SHOULD contain an ",(0,a.kt)("inlineCode",{parentName:"p"},"assertionMethod")," property that CAN be resolved to a verification method. The verification method SHOULD contain a ",(0,a.kt)("inlineCode",{parentName:"p"},"blockchainAccountId")," that specify the block chain address owning the NFT."),(0,a.kt)("p",null,"A Token Pass Verifier MAY skips DID Document generation and checks the claim against ownership info on chain."),(0,a.kt)("p",null,"Example of DID Document:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "@context": [\n    "https://www.w3.org/ns/did/v1",\n    "https://w3id.org/security/suites/secp256k1recovery-2020/v2"\n  ],\n  "id": "did:ethrnft:0x1:0x00420000123456789abcdef0123456789abcdef0:0x01d681",\n  "verificationMethod": [\n    {\n      "id": "did:ethrnft:0x1:0x00420000123456789abcdef0123456789abcdef0:0x01d681#owner",\n      "type": "EcdsaSecp256k1RecoveryMethod2020",\n      "controller": "did:ethr:0x1:0x00330000123456789abcdef0123456789abcdef0",\n      "blockchainAccountId": "eip155:1:0x00330000123456789abcdef0123456789abcdef0"\n    }\n  ],\n  "authentication": [\n    "did:ethrnft:0x1:0x00420000123456789abcdef0123456789abcdef0:0x01d681#owner"\n  ],\n  "assertionMethod": [\n    "did:ethrnft:0x1:0x00420000123456789abcdef0123456789abcdef0:0x01d681#owner"\n  ]\n}\n')),(0,a.kt)("h3",{id:"did-registry"},"DID Registry"),(0,a.kt)("p",null,"A DID resolver can use a DID registry in which delegations of ownership of an NFT are recorded. In this case, the DID Document may contain multiple verification method, each verification method may references a different blockchain address."),(0,a.kt)("p",null,"In this case, a Token Pass Generator SHOULD specify a verification method containing a delegated blockchain address. A Token Pass Verifier SHOULD select a matching verification method from the DID document."),(0,a.kt)("h2",{id:"verification"},"Verification"),(0,a.kt)("p",null,"Token Pass Verifier SHOULD take the following steps when checking credential in a Token Pass."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The payload MUST be a valid JSON document, or a encoded JSON document."),(0,a.kt)("li",{parentName:"ul"},"The payload MUST contain ",(0,a.kt)("inlineCode",{parentName:"li"},"VerifiableCredential")," as one of the strings in the ",(0,a.kt)("inlineCode",{parentName:"li"},"type")," property."),(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"issuanceDate")," is present, it MUST contain an ISO8601 date/time that is now or in the past."),(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"expirationDate")," is present, it MUST contain an ISO8601 date/time that is in the future."),(0,a.kt)("li",{parentName:"ul"},"The payload MUST contain a ",(0,a.kt)("inlineCode",{parentName:"li"},"credentialSubject")," property. Its value CAN be an object or a set of object."),(0,a.kt)("li",{parentName:"ul"},"Each object in the ",(0,a.kt)("inlineCode",{parentName:"li"},"credentialSubject")," property MUST contain an ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," property with a decentralized identity of the NFT as value.")),(0,a.kt)("p",null,"A Verifier SHOULD use the ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," of the object(s) in ",(0,a.kt)("inlineCode",{parentName:"p"},"credentialSubject")," property to fetch ownership information from chain. A DID Document SHOULD be resolved for each NFT claimed. All claimed NFT MUST be owned by or delegated to the same blockchain account."),(0,a.kt)("p",null,"Token Pass Verifier SHOULD take the following steps to verify the proof in a Token Pass:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The proof MUST contain a ",(0,a.kt)("inlineCode",{parentName:"li"},"type")," property with value set to ",(0,a.kt)("inlineCode",{parentName:"li"},"EthereumEip712Signature2021"),"."),(0,a.kt)("li",{parentName:"ul"},"The proof MUST contain a ",(0,a.kt)("inlineCode",{parentName:"li"},"proofPurpose")," property with value set to ",(0,a.kt)("inlineCode",{parentName:"li"},"assertionMethod"),"."),(0,a.kt)("li",{parentName:"ul"},"A matching ",(0,a.kt)("inlineCode",{parentName:"li"},"verificationMethod")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"proofPurpose")," MUST exist in the resolved DID document."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"proofValue")," MUST contains a signature that were signed by a blockchain account that is the same as the one specified in the ",(0,a.kt)("inlineCode",{parentName:"li"},"blockchainAccountId")," in the DID Document.")),(0,a.kt)("p",null,"Token Pass CAN be encoded as a QR code for presentation at a physical location. When decoding from a QR code, a Verifier SHOULD check that the payload is a JSON-formatted string. If the payload is not a JSON-formatted string, it SHOULD decode the payload using base45 encoding scheme. If the decoded payload is not JSON-formatted string, decompress the payload using zlib compression algorithm."),(0,a.kt)("h2",{id:"security-considerations"},"Security Considerations"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"To mitigate a replay attack, Token Pass Generator SHOULD include an ",(0,a.kt)("inlineCode",{parentName:"li"},"expirationDate")," in the Token Pass. Token Pass Verifier SHOULD require that ",(0,a.kt)("inlineCode",{parentName:"li"},"expirationDate")," be present and the value contains a date/time that is not too far in the future.")))}p.isMDXComponent=!0}}]);